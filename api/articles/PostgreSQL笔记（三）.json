{"title":"PostgreSQL笔记（三）","slug":"PostgreSQL笔记（三）","date":"2020-10-23T01:30:55.497Z","updated":"2020-10-23T08:39:53.574Z","comments":true,"excerpt":"","content":"<h1 id=\"PostgreSQL源码阅读（三）：查询编译\"><a href=\"#PostgreSQL源码阅读（三）：查询编译\" class=\"headerlink\" title=\"PostgreSQL源码阅读（三）：查询编译\"></a>PostgreSQL源码阅读（三）：查询编译</h1><p>​    好久没填坑了，最近抽空填一下。</p>\n<p>​    查询编译是PostgreSQL的核心组件之一。当进程Postgres收到查询语句后，根据语句类型的不同（如查询类型、创建类型）安排到不同的处理模块中。生成查询树后，交给下一部分重写模块，重写模块负责的是简化查询语句，避免冗余的结构。查询优化应该是整个数据库中最难的部分之一，尤其是其中涉及了大量的实现细节需要推敲。优化能够给性能带来巨大的提升，但由于优化过程是NP问题，并且还有数据原因，很难得到optimal结果。</p>\n<h2 id=\"查询分析\"><a href=\"#查询分析\" class=\"headerlink\" title=\"查询分析\"></a>查询分析</h2><p>​    PostgreSQL的词法、语法分析是借助Lex和yacc实现的。</p>\n<h2 id=\"查询重写\"><a href=\"#查询重写\" class=\"headerlink\" title=\"查询重写\"></a>查询重写</h2><p>​    PG的重写部分核心是规则系统，即根据一系列的规则来重写查询结果，这些规则都写在系统表pg_rewrite中。</p>\n<p>​    PG中定义规则的语法为</p>\n\n    <pre><code class=\"lang-sql\"><span class=\"hljs-keyword\">CREATE</span> [<span class=\"hljs-keyword\">OR REPLACE</span>] <span class=\"hljs-keyword\">RULE</span> <span class=\"hljs-type\">name</span> <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">ON</span> event\n<span class=\"hljs-keyword\">TO</span> <span class=\"hljs-keyword\">table</span> [<span class=\"hljs-keyword\">WHERE</span> condition]\n<span class=\"hljs-keyword\">DO</span> [<span class=\"hljs-keyword\">ALSO</span>|<span class=\"hljs-keyword\">INSTEAD</span>] &amp;#<span class=\"hljs-number\">123</span>;<span class=\"hljs-keyword\">NOTHING</span>|command|(command;comand..)&amp;#<span class=\"hljs-number\">125</span>;</code></pre>\n<h2 id=\"查询规划\"><a href=\"#查询规划\" class=\"headerlink\" title=\"查询规划\"></a>查询规划</h2><p>​    查询规划无疑是所有数据库中对执行效率影响最大的一环。优化的核心思想就是减少中间数据量。过程可以分为预处理、生成路径、生成计划三个阶段。</p>\n<h3 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h3><p>​    预处理主要工作是提升子链接和子查询以及预处理表达式和HAVING子句等。</p>\n<h4 id=\"子查询和子链接\"><a href=\"#子查询和子链接\" class=\"headerlink\" title=\"子查询和子链接\"></a>子查询和子链接</h4><p>​    子查询指可以<strong>独立</strong>出现的查询语句，而子链接指用于链接的表达式，通常出现在WHERE子句或者HAVING子句中。</p>\n<p>​    这部分试图将子查询及子链接中的表提取到FROM中，将链接条件移到WHERE子句中。</p>\n<h4 id=\"预处理表达式\"><a href=\"#预处理表达式\" class=\"headerlink\" title=\"预处理表达式\"></a>预处理表达式</h4><p>​    这部分的工作比较杂乱，包括：</p>\n<ul>\n<li>用关系变量取代别名</li>\n<li>进行常量化简</li>\n<li>对表达式进行规范</li>\n<li>将子链接转化成子计划</li>\n</ul>\n<h4 id=\"预处理HAVING子句\"><a href=\"#预处理HAVING子句\" class=\"headerlink\" title=\"预处理HAVING子句\"></a>预处理HAVING子句</h4><h3 id=\"生成路径\"><a href=\"#生成路径\" class=\"headerlink\" title=\"生成路径\"></a>生成路径</h3><p>​    生成路径的优化利用动态规划或者遗传算法。</p>\n<h2 id=\"后\"><a href=\"#后\" class=\"headerlink\" title=\"后\"></a>后</h2><p>​    这一部分实在是太复杂了，充斥着各种细节，直接读下去有种盲人摸象的感觉。想要对整个架构有更深层次的认知，还是需要把相关的论文读一遍。先留个坑，以后再填。</p>\n","categories":[],"tags":[]}