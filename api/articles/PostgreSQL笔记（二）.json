{"title":"PostgreSQL笔记（二）","slug":"PostgreSQL笔记（二）","date":"2020-09-10T12:37:00.814Z","updated":"2020-09-21T13:00:09.876Z","comments":true,"excerpt":"","content":"<h1 id=\"PostgreSQL源码阅读（二）：存储管理\"><a href=\"#PostgreSQL源码阅读（二）：存储管理\" class=\"headerlink\" title=\"PostgreSQL源码阅读（二）：存储管理\"></a>PostgreSQL源码阅读（二）：存储管理</h1><p>​    PostgreSQL对内存及外存管理的方式非常的经典，许多方法及实现细节都值得学习。存储的区分就不以图表画出来了，想要有宏观认识的同学建议先读一遍《PostgreSQL数据库内核分析》。</p>\n<h2 id=\"外存管理\"><a href=\"#外存管理\" class=\"headerlink\" title=\"外存管理\"></a>外存管理</h2><h3 id=\"表和元组的存储\"><a href=\"#表和元组的存储\" class=\"headerlink\" title=\"表和元组的存储\"></a>表和元组的存储</h3><p>​    数据在磁盘中以文件块的形式存储，称之为page（和内存里的块重名了，注意区分）。每个page都有page header描述page结构以及指向存储的数据，page结构如下。</p>\n\n    <pre><code class=\"lang-shell\"><span class=\"hljs-code\">+----------------+</span>---------------------------------+\n<span class=\"hljs-section\">| PageHeaderData | linp1 linp2 linp3 ...           |\n+-----------+----+---------------------------------+</span>\n<span class=\"hljs-section\">| ... linpN |                                      |\n+-----------+--------------------------------------+</span>\n|           ^ pd<span class=\"hljs-emphasis\">_lower                              |\n|                                                  |\n|             v pd_</span>upper                              |\n<span class=\"hljs-code\">+-------------+</span>------------------------------------+\n<span class=\"hljs-section\">|             | tupleN ...                         |\n+-------------+------------------+-----------------+</span>\n<span class=\"hljs-section\">|       ... tuple3 tuple2 tuple1 | &quot;special space&quot; |\n+--------------------------------+-----------------+</span>\n<span class=\"hljs-code\">                                    ^ pd_special</span></code></pre>\n<p>​    每个linp指向对应的元组起始位置，长度，以及是否使用，元组在page内按照从后向前顺序存储，但是在page最后留了一块特殊空间留作它用，这个特殊块忘了有啥用了（。＾▽＾）。</p>\n<p>​    PageHeader记录了关于块的一切信息，结构如下</p>\n\n    <pre><code class=\"lang-c\">typedef struct PageHeaderData\n&amp;<span class=\"hljs-comment\">#123;</span>\n    /* XXX LSN <span class=\"hljs-keyword\">is</span> member <span class=\"hljs-keyword\">of</span> *any* block, <span class=\"hljs-keyword\">not</span> only page-organized ones */\n    PageXLogRecPtr pd_lsn;        /* LSN: next byte <span class=\"hljs-keyword\">after</span> <span class=\"hljs-keyword\">last</span> byte <span class=\"hljs-keyword\">of</span> xlog\n                                 * <span class=\"hljs-built_in\">record</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">last</span> change <span class=\"hljs-keyword\">to</span> this page */\n    uint16        pd_checksum;    /* checksum */\n    uint16        pd_flags;        /* flag bits, see <span class=\"hljs-keyword\">below</span> */\n    LocationIndex pd_lower;        /* <span class=\"hljs-built_in\">offset</span> <span class=\"hljs-keyword\">to</span> start <span class=\"hljs-keyword\">of</span> free <span class=\"hljs-literal\">space</span> */\n    LocationIndex pd_upper;        /* <span class=\"hljs-built_in\">offset</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">of</span> free <span class=\"hljs-literal\">space</span> */\n    LocationIndex pd_special;    /* <span class=\"hljs-built_in\">offset</span> <span class=\"hljs-keyword\">to</span> start <span class=\"hljs-keyword\">of</span> special <span class=\"hljs-literal\">space</span> */\n    uint16        pd_pagesize_version;\n    TransactionId pd_prune_xid; /* oldest prunable XID, <span class=\"hljs-keyword\">or</span> zero <span class=\"hljs-keyword\">if</span> none */\n    ItemIdData    pd_linp[FLEXIBLE_ARRAY_MEMBER]; /* line pointer array */\n&amp;<span class=\"hljs-comment\">#125; PageHeaderData;</span></code></pre>\n<p>​    其中pd_special指向的是特殊空间的起始地址，但是我记得过往版本这个地址是固定的，读者可以自行求证。</p>\n<p>​    在每个linp指向的元组，在实际数据前还有个HeapTupleHeader，这个结构记录了对该元组的事务ID和命令ID。这个数据记录的东西有点复杂，目前不打算详细解释，在后面有机会再详细阐述。</p>\n<h3 id=\"磁盘管理器\"><a href=\"#磁盘管理器\" class=\"headerlink\" title=\"磁盘管理器\"></a>磁盘管理器</h3><p>​    PostgreSQL支持多种存储介质，但目前只实现了磁盘管理，而且到现在（12.x）还是没有更多的实现。src/backend/storage/smgr下提供了外存管理接口。</p>\n<h4 id=\"smgr\"><a href=\"#smgr\" class=\"headerlink\" title=\"smgr\"></a>smgr</h4><p>​    smgr.c文件里有个我没有遇到过的写法，就是下面这个：</p>\n\n    <pre><code class=\"lang-c\">static const f_smgr smgrsw[] = &amp;<span class=\"hljs-comment\">#123;</span>\n    <span class=\"hljs-comment\">/* magnetic disk */</span>\n    &amp;<span class=\"hljs-comment\">#123;</span>\n        .<span class=\"hljs-attr\">smgr_init</span> = mdinit,\n        .<span class=\"hljs-attr\">smgr_shutdown</span> = NULL,\n        .<span class=\"hljs-attr\">smgr_close</span> = mdclose,\n        .<span class=\"hljs-attr\">smgr_create</span> = mdcreate,\n        .<span class=\"hljs-attr\">smgr_exists</span> = mdexists,\n        .<span class=\"hljs-attr\">smgr_unlink</span> = mdunlink,\n        .<span class=\"hljs-attr\">smgr_extend</span> = mdextend,\n        .<span class=\"hljs-attr\">smgr_prefetch</span> = mdprefetch,\n        .<span class=\"hljs-attr\">smgr_read</span> = mdread,\n        .<span class=\"hljs-attr\">smgr_write</span> = mdwrite,\n        .<span class=\"hljs-attr\">smgr_writeback</span> = mdwriteback,\n        .<span class=\"hljs-attr\">smgr_nblocks</span> = mdnblocks,\n        .<span class=\"hljs-attr\">smgr_truncate</span> = mdtruncate,\n        .<span class=\"hljs-attr\">smgr_immedsync</span> = mdimmedsync,\n    &amp;<span class=\"hljs-comment\">#125;</span>\n&amp;<span class=\"hljs-comment\">#125;;</span></code></pre>\n<p>​    这个是c99的语法，指定结构内变量初始化。其中的f_smgr结构为所有的外存提供了统一的操作接口。</p>\n<h3 id=\"VFD\"><a href=\"#VFD\" class=\"headerlink\" title=\"VFD\"></a>VFD</h3><p>​    VFD，虚拟文件描述符，用来绕开操作系统打开文件数量的限制。文件替策略换采用LRU。</p>\n<h3 id=\"空闲空间映射表（fsm）\"><a href=\"#空闲空间映射表（fsm）\" class=\"headerlink\" title=\"空闲空间映射表（fsm）\"></a>空闲空间映射表（fsm）</h3><p>​    fsm文件用于记录空闲空间，映射表空间内部记录表中文件块空闲区大小，且使用三层树结构来组织空闲空间，前两层只记录子结点最大的空闲空间，最后一层记录空闲空间大小。</p>\n<p>​    表操作略。</p>\n<h3 id=\"可见性映射表（VM）\"><a href=\"#可见性映射表（VM）\" class=\"headerlink\" title=\"可见性映射表（VM）\"></a>可见性映射表（VM）</h3><p>​    VM是为了满足多版本并发控制。对于元组删除或者更新，并不会直接物理删除，而是通过标记删除，最终调用VACUUM进程来清楚这些元组。</p>\n<h3 id=\"大数据存储\"><a href=\"#大数据存储\" class=\"headerlink\" title=\"大数据存储\"></a>大数据存储</h3><p>​    PostgreSQL提供两种方法存储大数据，一种是TOAST，一种是大对象机制。</p>\n<h4 id=\"TOAST-The-Oversized-Attribute-Storage-Technique\"><a href=\"#TOAST-The-Oversized-Attribute-Storage-Technique\" class=\"headerlink\" title=\"TOAST (The Oversized-Attribute Storage Technique)\"></a>TOAST (The Oversized-Attribute Storage Technique)</h4><p>​    TOAST在PostgreSQL12中找不到了，估计已经被抛弃了。</p>\n<h4 id=\"大对象机制\"><a href=\"#大对象机制\" class=\"headerlink\" title=\"大对象机制\"></a>大对象机制</h4><p>​    所有的大对象都被存储在pg_largeobject系统表下，每个大对象以OID标识，且将大对象分割成多个元组存放在系统表中。</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p>​    PostgreSQL将内存分配器重新包装了一层，使得整个系统获得了垃圾回收机制，而系统申请释放内存的方式几乎没变。</p>\n<h3 id=\"内存上下文\"><a href=\"#内存上下文\" class=\"headerlink\" title=\"内存上下文\"></a>内存上下文</h3><p>​    内存上下文是PG内存管理的核心机制，本质是记录跟踪每个被分配的内存，从而提高内存使用效率，减少冗余的系统内存管理。</p>\n<h4 id=\"MemoryContext\"><a href=\"#MemoryContext\" class=\"headerlink\" title=\"MemoryContext\"></a>MemoryContext</h4><p>​    所有的内存以及内存上下文都以树的形式组成，其中所有的内结点都是内存上下文，一般所有的叶结点都是内存（除非内存上下文没有分配内存）。所有的进程都有自己的内存上下文树，且树的根结点一定为TopMemoryContext。</p>\n<p>​    与普通的内存管理稍微有点区别的是，在不同情况下，PG内存分配的上下文可能是不同，所以需要先进行切换内存上下文，再进行内存分配/回收。</p>\n<p>​    上下文内所有的内存以block形式分配，block内还进行chunk再进行分配，被释放的空间以链表形式记录在freeList中。</p>\n<h4 id=\"内存上下文初始化与创建\"><a href=\"#内存上下文初始化与创建\" class=\"headerlink\" title=\"内存上下文初始化与创建\"></a>内存上下文初始化与创建</h4><p>​    每个PostgreSQL进程初始化后都要先建立内存上下文，该工作由MemoryContextInit完成。初始化建立了TopMemoryContext和ErrorContext两个上下文，前者是所有上下文的根结点。</p>\n<p>​    内存上下文的创建由MemoryContextCreate函数来完成，即从TopMemoryContext申请一块略大于上下文结点的内存块。</p>\n<h4 id=\"内存上下文的内存分配\"><a href=\"#内存上下文的内存分配\" class=\"headerlink\" title=\"内存上下文的内存分配\"></a>内存上下文的内存分配</h4><p>​    内存分配的情况要考虑的情况比较多，笼统的讲，就是根据所需内存大小，找到适合的FreeList中或者新内存块中适合的位置分配出去。</p>\n<h3 id=\"高速缓存\"><a href=\"#高速缓存\" class=\"headerlink\" title=\"高速缓存\"></a>高速缓存</h3><p>​    PostgreSQL中的高速缓存，即在内存中开辟的空间，用来存储经常访问的系统表信息。</p>\n<p>​    Cache分两种：SysCache和RelCache。</p>\n<p>​    这两个表的细分功能暂且不是很理解，就不详细展开。</p>\n<h3 id=\"缓冲池管理\"><a href=\"#缓冲池管理\" class=\"headerlink\" title=\"缓冲池管理\"></a>缓冲池管理</h3><p>​    缓冲池是对于普通表元组访问加速。缓冲池分为共享缓冲池和本地缓冲池，前者用于普通可共享表存储，后者用于临时表存储。</p>\n<p>​    其它暂略。</p>\n<h3 id=\"IPC\"><a href=\"#IPC\" class=\"headerlink\" title=\"IPC\"></a>IPC</h3><p>​    PostgreSQL利用共享内存实现进程间通信。</p>\n<h2 id=\"表操作与元组操作\"><a href=\"#表操作与元组操作\" class=\"headerlink\" title=\"表操作与元组操作\"></a>表操作与元组操作</h2><p>​    上层模块通过表与元组存储操作来调用存储模块功能。</p>\n<h3 id=\"表操作\"><a href=\"#表操作\" class=\"headerlink\" title=\"表操作\"></a>表操作</h3><h4 id=\"打开表\"><a href=\"#打开表\" class=\"headerlink\" title=\"打开表\"></a>打开表</h4><p>​    与操作系统相似，表打开时并没有打开具体的表，而是打开关系描述符–RelationData，存在RelCache中（RelCache的功能清楚了）。</p>\n<h4 id=\"扫描表\"><a href=\"#扫描表\" class=\"headerlink\" title=\"扫描表\"></a>扫描表</h4><p>​    没有索引情况下，</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>略。</p>\n","categories":[],"tags":[{"name":"Database, PostgreSQL","path":"api/tags/Database, PostgreSQL.json"}]}